<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Presentation Mode — Athlete Combine Dashboard</title>
<style>
  :root{
    --bg:#070b16;
    --panel: rgba(255,255,255,.06);
    --border: rgba(255,255,255,.14);
    --text:#eef3ff;
    --muted:#a7b3d6;
    --accent:#51CAF5;
    --accent2:#5471B7;
    --radius:18px;
    --shadow: 0 20px 70px rgba(0,0,0,.55);
    --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family:var(--font);
    color:var(--text);
    background:
      radial-gradient(1200px 600px at 20% -10%, rgba(81,202,245,.16), transparent 60%),
      radial-gradient(900px 500px at 90% 10%, rgba(84,113,183,.18), transparent 60%),
      var(--bg);
    overflow:hidden;
  }

  .wrap{
    height:100%;
    display:grid;
    grid-template-rows: auto 1fr;
  }

  .topbar{
    padding: 14px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    border-bottom: 1px solid rgba(255,255,255,.10);
    background: linear-gradient(to bottom, rgba(7,11,22,.88), rgba(7,11,22,.55));
    backdrop-filter: blur(10px);
  }
  .brand{
    display:flex;
    flex-direction:column;
    gap:4px;
    min-width: 220px;
  }
  .brand .title{
    font-weight: 800;
    letter-spacing: .2px;
    font-size: 16px;
    margin:0;
  }
  .brand .sub{
    color: var(--muted);
    font-size: 12px;
  }

  .actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
  .btn{
    appearance:none;
    border: 1px solid var(--border);
    background: rgba(255,255,255,.06);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 12px;
    cursor:pointer;
    font-size: 13px;
    line-height:1;
    user-select:none;
  }
  .btn:hover{ border-color: rgba(81,202,245,.35); }
  .btn:active{ transform: translateY(1px); }
  .btnGhost{ background: transparent; }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    border:1px solid rgba(255,255,255,.18);
    padding: 5px 10px;
    border-radius: 999px;
    font-size: 12px;
    background: rgba(255,255,255,.06);
  }

  .stage{
    padding: 18px;
    display:grid;
    place-items:center;
  }
  .card{
    width: min(1100px, 100%);
    border: 1px solid rgba(255,255,255,.12);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .cardInner{
    padding: 22px;
    display:grid;
    grid-template-columns: 340px 1fr;
    gap: 18px;
  }

  .photo{
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 16px;
    background: rgba(0,0,0,.18);
    overflow:hidden;
    min-height: 360px;
    display:flex;
    align-items:center;
    justify-content:center;
    color: rgba(255,255,255,.45);
    position:relative;
  }
  .photo img{
    width:100%;
    height:100%;
    object-fit: cover;
    display:block;
  }

  .name{
    font-size: 40px;
    font-weight: 900;
    letter-spacing: .2px;
    margin:0 0 10px 0;
  }
  .metaRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-bottom: 14px;
  }

  .grid{
    display:grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 12px;
  }
  .stat{
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.16);
    border-radius: 14px;
    padding: 12px;
  }
  .stat .k{
    color: var(--muted);
    font-size: 12px;
    margin-bottom: 6px;
  }
  .stat .v{
    font-size: 18px;
    font-weight: 800;
    letter-spacing: .2px;
  }

  .footerHint{
    padding: 12px 18px;
    border-top: 1px solid rgba(255,255,255,.10);
    color: var(--muted);
    font-size: 12px;
    display:flex;
    justify-content:space-between;
    gap:12px;
    flex-wrap:wrap;
  }

  @media (max-width: 900px){
    .cardInner{ grid-template-columns: 1fr; }
    .photo{ min-height: 260px; }
    .name{ font-size: 32px; }
    .grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
  }
  @media (max-width: 520px){
    .stage{ padding: 12px; }
    .cardInner{ padding: 14px; }
    .name{ font-size: 26px; }
    .grid{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <h1 class="title">Presentation Mode</h1>
        <div class="sub">Arrow keys: Prev/Next • F: Fullscreen • Esc: Exit fullscreen</div>
      </div>
      <div class="actions">
        <span class="pill" id="counterPill">— / —</span>
        <button class="btn" id="prevBtn" type="button">Prev</button>
        <button class="btn" id="nextBtn" type="button">Next</button>
        <button class="btn btnGhost" id="fsBtn" type="button">Fullscreen</button>
        <button class="btn btnGhost" id="exitBtn" type="button">Exit</button>
      </div>
    </div>

    <div class="stage">
      <div class="card" role="region" aria-label="Presentation card">
        <div class="cardInner">
          <div class="photo">
            <img id="photoImg" alt="" style="display:none"/>
            <div id="photoFallback">No photo</div>
          </div>

          <div>
            <h2 class="name" id="name">—</h2>
            <div class="metaRow" id="metaRow"></div>

            <div class="grid" id="stats"></div>
          </div>
        </div>

        <div class="footerHint">
          <div id="school">—</div>
          <div id="location">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const PRES_KEY = "ac_presenter_current_athlete";

  let _photoReq = 0;
  let _currentAthleteKey = "";
  const el = {
    name: document.getElementById("name"),
    metaRow: document.getElementById("metaRow"),
    stats: document.getElementById("stats"),
    school: document.getElementById("school"),
    location: document.getElementById("location"),
    photoImg: document.getElementById("photoImg"),
    photoFallback: document.getElementById("photoFallback"),
    counterPill: document.getElementById("counterPill"),
    fsBtn: document.getElementById("fsBtn"),
    exitBtn: document.getElementById("exitBtn"),
    prevBtn: document.getElementById("prevBtn"),
    nextBtn: document.getElementById("nextBtn"),
  };

  const pick = (obj, keys) => {
    for(const k of keys){
      if(obj && obj[k] !== undefined && obj[k] !== null && String(obj[k]).trim() !== "") return obj[k];
    }
    return "";
  };

  function esc(s){
    return String(s ?? "—")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function getSelFromHash(){
    const h = (window.location.hash || "").trim();
    const m = h.match(/#sel=([^&]+)/i);
    return m ? decodeURIComponent(m[1]) : "";
  }

  function normId(v){
    const s = String(v ?? "").trim();
    if(!s) return "";
    return s.replace(/^0+/, "") || "0";
  }

  function initials(name){
    const parts = String(name||"").trim().split(/\s+/).filter(Boolean);
    if(!parts.length) return "—";
    const a = (parts[0]||"")[0]||"";
    const b = (parts[parts.length-1]||"")[0]||"";
    return (a+b).toUpperCase();
  }

  function setPhotoUrl(url, nameForFallback, reqKey){
    // reqKey guards against async races (old requests overwriting new renders)
    const myKey = reqKey || "";
    const fallbackText = initials(nameForFallback);

    if(el.photoFallback){
      el.photoFallback.textContent = fallbackText;
      el.photoFallback.style.display = "flex";
    }
    if(el.photoImg){
      // Hide until we confirm load; prevents flicker-to-initials after partial loads
      el.photoImg.style.display = "none";

      if(!url){
        el.photoImg.removeAttribute("src");
        return;
      }

      const imgEl = el.photoImg;
      const thisReq = _photoReq;
      imgEl.onload = () => {
        // Only apply if still the latest render
        if(thisReq !== _photoReq) return;
        if(el.photoFallback) el.photoFallback.style.display = "none";
        imgEl.style.display = "block";
      };
      imgEl.onerror = () => {
        if(thisReq !== _photoReq) return;
        if(el.photoFallback){
          el.photoFallback.textContent = fallbackText;
          el.photoFallback.style.display = "flex";
        }
        imgEl.style.display = "none";
      };

      imgEl.src = url;
    }
  }

  async function resolvePhoto(r){
    const direct = pick(r, ["_photoUrl", "photoUrl", "PhotoUrl"]);
    if(direct) return direct;

    const id = pick(r, ["Formulario#", "Formulario", "ID", "Id", "id"]);
    const candidates = [
      `photos/${id}.jpg`,
      `photos/${id}.jpeg`,
      `photos/${id}.png`,
      `photos/${id}.webp`,
    ].filter(() => id);

    for(const url of candidates){
      try{
        const img = new Image();
        await new Promise((ok, bad) => {
          img.onload = ok;
          img.onerror = bad;
          img.src = url;
        });
        return url;
      }catch(e){}
    }
    return "";
  }

  function renderStatsGrid(r){
    if(!el.stats) return;

    // Show a clean set of common fields if present, otherwise show first few numeric-ish fields.
    const primary = [
      ["Age", ["Age","Edad","age"]],
      ["Height", ["Height","Altura","height"]],
      ["Weight", ["Weight","Peso","weight"]],
      ["Position", ["Pos","Position","Posición","position"]],
      ["Team", ["Team","Equipo","team"]],
      ["Sport", ["Sport","Deporte","sport"]],
    ];

    const items = [];
    for(const [label, keys] of primary){
      const v = pick(r, keys);
      if(v !== "") items.push([label, v]);
    }

    // Fallback: add up to 6 additional fields that look like combine metrics
    if(items.length < 4 && r){
      const metricHints = ["40", "dash", "yard", "vertical", "broad", "bench", "shuttle", "cone", "agility", "sprint", "jump"];
      for(const k of Object.keys(r)){
        if(items.length >= 10) break;
        const lk = k.toLowerCase();
        if(primary.some(([_, keys]) => keys.includes(k))) continue;
        if(metricHints.some(h => lk.includes(h)) || /\d/.test(lk)){
          const v = String(r[k] ?? "").trim();
          if(v) items.push([k, v]);
        }
      }
    }

    if(!items.length){
      el.stats.innerHTML = '<div class="stat"><span class="k">—</span><span class="v">—</span></div>';
      return;
    }

    el.stats.innerHTML = items.map(([k,v]) =>
      `<div class="stat"><span class="k">${esc(k)}</span><span class="v">${esc(v)}</span></div>`
    ).join("");
  }

  async function renderAthlete(r){
    if(!r) return;

    const name = pick(r, ["Nombre","Name","Athlete","athlete","Player","player"]) || "—";
    const pos  = pick(r, ["Pos","Position","Posición","position"]) || "";
    const sport = pick(r, ["Sport","Deporte","sport"]) || "";
    const team  = pick(r, ["Team","Equipo","team"]) || "";

    const school = pick(r, ["School","Colegio","Escuela","school"]) || "";
    const location = pick(r, ["Location","Ubicación","Ciudad","Provincia","location"]) || "";

    if(el.name) el.name.textContent = name;
    if(el.metaRow) el.metaRow.textContent = [sport, pos, team].filter(Boolean).join(" • ") || "—";
    if(el.school) el.school.textContent = school || "—";
    if(el.location) el.location.textContent = location || "—";

    renderStatsGrid(r);

    const photo = await resolvePhoto(r);
    setPhotoUrl(photo, name);
  }

  function tryLoadFromStorage(){
    try{
      const raw = localStorage.getItem(PRES_KEY);
      if(!raw) return false;
      const payload = JSON.parse(raw);
      if(payload?.type === "ac_athlete_update" && payload?.athlete){
        renderAthlete(payload.athlete);
        return true;
      }
    }catch(e){}
    return false;
  }

  function parseCsvSimple(text){
    const rows = [];
    let i = 0, field = "", row = [], inQuotes = false;
    const pushField = () => { row.push(field); field = ""; };
    const pushRow = () => { rows.push(row); row = []; };

    while(i < text.length){
      const c = text[i];
      if(inQuotes){
        if(c === '"'){
          const next = text[i+1];
          if(next === '"'){ field += '"'; i += 2; continue; }
          inQuotes = false; i++; continue;
        }
        field += c; i++; continue;
      }else{
        if(c === '"'){ inQuotes = true; i++; continue; }
        if(c === ','){ pushField(); i++; continue; }
        if(c === '\r'){ i++; continue; }
        if(c === '\n'){ pushField(); pushRow(); i++; continue; }
        field += c; i++; continue;
      }
    }
    pushField();
    if(row.length > 1 || (row.length === 1 && row[0] !== "")) pushRow();

    if(!rows.length) return [];
    const headers = rows[0].map(h => String(h).trim());
    const out = [];
    for(let r = 1; r < rows.length; r++){
      const obj = {};
      for(let c = 0; c < headers.length; c++){
        obj[headers[c]] = rows[r][c] ?? "";
      }
      out.push(obj);
    }
    return out;
  }

  async function fetchResultsCsvText(){
    // Resolve from directory (ignore hash/query)
    const dir = window.location.origin + window.location.pathname.replace(/[^\/]*$/, "");
    const url1 = new URL("./results.csv", dir).toString();

    let res = await fetch(url1, { cache: "no-store" });
    if(res.ok) return await res.text();

    // fallback: try without "./"
    const url2 = new URL("results.csv", dir).toString();
    res = await fetch(url2, { cache: "no-store" });
    if(res.ok) return await res.text();

    throw new Error("results.csv not reachable");
  }

  async function loadFromCsvBySel(){
    const selRaw = getSelFromHash();
    if(!selRaw) return false;

    try{
      const text = await fetchResultsCsvText();
      const list = (window.Papa && window.Papa.parse)
        ? window.Papa.parse(text, { header:true, skipEmptyLines:true }).data
        : parseCsvSimple(text);

      const selN = normId(selRaw);
      const candidates = ["Formulario#", "Formulario", "ID", "Id", "id"];
      let found = null;

      for(const r of list){
        for(const k of candidates){
          if(r && Object.prototype.hasOwnProperty.call(r, k)){
            const v = String(r[k] ?? "").trim();
            if(!v) continue;
            const vN = normId(v);
            if(v === selRaw || vN === selN){
              found = r;
              break;
            }
          }
        }
        if(found) break;
      }

      if(found){
        await renderAthlete(found);
        if(el.counterPill) el.counterPill.textContent = `#${String(selRaw).padStart(3,"0")}`;
        return true;
      }

      if(el.counterPill) el.counterPill.textContent = `#${String(selRaw).padStart(3,"0")}`;
      return false;

    }catch(err){
      console.warn(err);
      return false;
    }
  }

  async function hydrate(){
    // Update counter pill immediately from hash
    const sel = getSelFromHash();
    if(el.counterPill && sel) el.counterPill.textContent = `#${String(sel).padStart(3,"0")}`;

    // Storage first (fast), then hash lookup (authoritative)
    const hadStorage = tryLoadFromStorage();
    const hadSel = await loadFromCsvBySel();

    if(!hadStorage && !hadSel){
      // Show a lightweight hint in the meta row if nothing loaded
      if(el.metaRow) el.metaRow.textContent = "Waiting for selection…";
    }
  }

  // Fullscreen / exit button hooks
  async function toggleFullscreen(){
    try{
      if(!document.fullscreenElement){
        await document.documentElement.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){}
  }
  el.fsBtn?.addEventListener("click", toggleFullscreen);
  el.exitBtn?.addEventListener("click", () => { try{ window.close(); }catch(e){} });

  // Live updates via storage + hash
  window.addEventListener("storage", (ev) => {
    if(ev.key === PRES_KEY){
      tryLoadFromStorage();
    }
  });
  window.addEventListener("hashchange", () => { hydrate(); });

  hydrate();
})();
</script>

</body>
</html>
